%% Integrator Lab: Solving First Order ODEs in MATLAB and Picard Approximation
%
% This lab will teach you to numerically solve first order ODEs using a
% built in MATLAB integrator, |ode45|.  |ode45| is a good, general purpose
% tool for integrating first order equations (and first order systems).  It
% is not always the right algorithm, but it is usually the right algorithm
% to try first. This lab will also teach you how to manipulate symbolic
% functions in MATLAB.
%
% You will learn how to use the |ode45| routine, how to interpolate between
% points, and how MATLAB handles data structures.  You will also learn how
% to use MATLAB for exact symbolic calculations and write your own Picard
% approximation code.
% 
% Opening the m-file lab2.m in the MATLAB editor, step through each
% part using cell mode to see the results.  Compare the output with the
% PDF, which was generated from this m-file.
%
% There are eight exercises in this lab that are to be handed in at the
% end of the lab.  Write your solutions in the template, including
% appropriate descriptions in each step. Save the .m file and submit it 
% online using Quercus.
%
%% Student Information
%
% Student Name: Edwin Chacko
%
% Student Number: 1009149716
%

%% Exercise 1
%
% Objective: Solve an initial value problem and plot both the numerical
% approximation and the corresponding exact solution.
%
% Details: Solve the IVP
%
% |y' = y tan t + sin t, y(0) = -1/2|
%
% from |t = 0| to |t = pi|.
%
% Compute the exact solution (by hand), and plot both on the same figure
% for comparison, as above.
%
% Your submission should show the construction of the inline function, the
% use of ode45 to obtain the solution, a construction of the exact
% solution, and a plot showing both.  In the comments, include the exact
% solution.
%
% Label your axes and include a legend.

clear all;
% GENERAL SOLUTION:
% y(t) = 1/2 [tan(t)sin(t) + sec(t)]

% Numerical slolution
t = linspace(0, pi);
f = @(t) 1/2 .* (tan(t).*sin(t) - sec(t));


% ode45 solution
ode = @(t, y) y .* tan(t) + sin(t);

t0 = 0;
t1 = pi;
y0 = -0.5;
solution = ode45(ode, [t0, t1], y0);

% Plotting
hold on;
general = plot(t, f(t), 'b');
ode_45 = plot(solution.x, solution.y);

% Add labels and title 
xlabel('t');
ylabel('y(t)');
title("General and ODE45 Solution to |y' = ytan(t) + sin(t), y(0) = -1/2|");
legend([general, ode_45], {'General Solution', 'ODE45 Solution'}, 'Location', 'northwest');

grid on;
hold off;

%% Exercise 2
% 
% Objective: Interpolate a solution at a number of grid points
%
% Details: For the solution you computed in exercise 1, use deval to
% compute the interpolated values at 10 grid points between 2 and 3.

% Define and plot
x = linspace(2,3,10);
interpolated = deval(solution, x);

% Plot
figure;  
plot(x, interpolated, 'o-',  'Color', 'b');

% Readability
xlabel('t');
ylabel('y(t)');  
title('Interpolated Solution To Exercise 1');  
legend('Interpolated ODE45 Solution', 'location', 'southeast');  
grid on;  


%% Exercise 3
%
% Objective: Examine the error of a solution generated by |ode45|
%
% Details: For your solution to exercise 1, compute the pointwise error,
% identify the maximum value of the error, and visualize the error on a 
% linear-log plot (use semilogy to plot the log of the error vs. t).  
% Write in the comments where the error is largest, and give a brief 
% (1-2 sentences) explanation of why it is largest there.  Make sure to 
% label your axes.
% Numerical slolution
t = linspace(0, pi);
f = @(t) 1/2 .* (tan(t).*sin(t) - sec(t));


% ode45 solution
ode = @(t, y) y .* tan(t) + sin(t);

t0 = 0;
t1 = pi;
y0 = -0.5;
solution = ode45(ode, [t0, t1], y0);

% Calculating error
y_exact = f(solution.x); % f defined in exercise 1
error = abs(y_exact - solution.y);

% Max error and its location
[max_error, idx] = max(error);
fprintf('maximum error: %g at t = %g\n', max_error, solution.x(idx));
% MAX ERROR: at t = 1.55881.

% Plotting
semilogy(solution.x, error);
xlabel('t');
ylabel('Log of Error');
title('Error versus t in a Logarithmic Scale');

% The maximum error occurs near t = 1.55881 due to the behaviour of tan(t)
% as it approaches a discontinuity at t = pi/2. This region of rapid change
% likely poses challenges for the ode45 solver, leading to greater error.

%% Exercise 4
%
% Objective: Solve and visualize a nonlinear ode using ode45
%
% Details: Solve the IVP
%
% |y' = 1 / y^2 , y(1) = 1|
%
% from |t=1| to |t=10| using |ode45|.  Find the exact solution and compute
% the maximum pointwise error.  Then plot the approximate solution and the
% exact solution on the same axes.
%
% Your solution should show the definition of the inline function,
% the computation of its solution in this interval, the computation of the
% exact solution at the computed grid points, the computation of the
% maximum error, and a plot of the exact and approximate solutions.
% Your axes should be appropriately labeled and include a legend.

% GENERAL SOLUTION: 
% y = (3t + 3C) ^ (1/3)
% PARTICULAR SOLUTION: 
% y(t) = (3t - 2) ^ (1/3)

clear all;

% Defining ODE
t = linspace(1, 10);
f = @(t, y) (y.^-2);
part_soln = @(t) (3*t - 2) .^ (1/3);
t0 = 1;
t1 = 10;
y0 = 1;

% Solve with ODE45
solution = ode45(f, [t0, t1], y0);
% Y Exact
y_exact = part_soln(t);
y_exp = part_soln(solution.x);
disp(solution)

% Maximum error
abs_error = abs(y_exp - solution.y);
max_error = max(abs_error);
fprintf("max error: %g\n", max_error);

% Plot
figure;
plot(t, y_exact, 'b', 'LineWidth', 1.5, 'DisplayName', 'Exact Solution');
hold on;
plot(solution.x, solution.y, 'rx', 'MarkerSize', 10, 'DisplayName', 'ODE45 Solution');

% Readability
xlabel('t');
ylabel('y(t)');
title('Comparison of Exact and ODE45 Solution for y'' = 1/y^2');
legend('Location', 'northwest');
grid on;
hold off;
%% Exercise 5
%
% Objective: Solve and visualize an ODE that cannot be solved by hand with
% |ode45|.
%
% Details: Solve the IVP
%
% |y' =  1 - t y / 2, y(0) = -1|
%
% from |t=0| to |t=10|.  
%
% Your solution should show you defining the inline function, computing
% the solution in this interval, and plotting it.
%
% Your axes should be appropriately labeled

clear all; 

% Defining ODE
y = @(t, y) 1 - t.*y/2;
t0 = 0;
t1 = 10;
y0 = -1;

% Computing Soltion
solution = ode45(y, [t0, t1], y0);

% Plotting
plot(solution.x, solution.y, 'x-', 'markersize', 10);

% Readability
title("Solution to |y' =  1 - t y / 2, y(0) = -1|");
xlabel('t');
ylabel('y(t)');

%% Exercise 6 - When things go wrong
%
% Objective: Solve an ode and explain the warning message
%
% Details: Solve the IVP:
%
% |y' = y^3 - t^2, y(0) = 1|
%
% from |t=0| to |t=1|.  
%
% Your solution should show you defining the inline function, and computing
% the solution in this interval.
% 
% If you try to plot the solution, you should find that the solution does
% not make it all the way to t = 1.
%
% In the comments explain why MATLAB generates the warning message that you
% may see, or fails to integrate all the way to t=1.  HINT: Try plotting
% the direction field for this with IODE.

clear all;

% Defining ODE
y = @(t, y) y.^3 - t.^2;
t0 = 0;
t1 = 1;
y0 = 1;

% Solving with ODE45
solution = ode45(y, [t0, t1], y0);

plot(solution.x, solution.y);

% Observing the direction field plot for the given differential equation
% using IODE, it becomes evident that there's a point where the slope
% seems to be approaching infinity before t = 1.
%
% When employing ODE45 to approximate this function's solution, the function's
% rapid ascension towards infinity poses a challenge. The solver struggles
% to determine an adequately small step size that would allow the error to
% be within acceptable tolerances. This behavior is responsible for the warning
% message, indicating that the solver can't maintain the necessary tolerances
% without reducing the step size beyond permissible limits.

%% Exercise 7
% Objective: Define a function using symbolic variables and manipulate it.
%
% Details: Define the function |f(x) = sin(x)cos(x)|
%
% Use MATLAB commands to obtain a simpler form of this function, compute
% value of this function for |x=pi/4| and |x=1|, and plot its graph.
clear all;
% Defining function
syms x;
g = cos(x)*sin(x);

% Simplifying
f = simplify(g);

% Computing specied values
eval(subs(f,x,pi/4));
eval(subs(f,x,1));

% PLot
ezplot(f)

% Readability
xlabel('x');
ylabel('f(x)');
title('f(x) = sin(x)cos(x)');

%% Exercise 8
%
%  Objective: Solve your own Picard Approximation and compare it to the
%  exact solution.
%
%  Details: Consider the IVP
%     | y' = 1+y^2|
%     | y(0) = 1 |
%
% Find the Picard approximation phi_5. 
% For better efficiency, do not keep all the previous approximations.
%
% Compute the exact solution (by hand), and plot both on the same figure
% for comparison, as above.
%
% Label your axes and include a legend.
%
% HINT. The initial condition has 1 instead of 0, so the Picard
% method needs to be adapted.

clear all;

% Define ODE
syms t s y;
f = 1+y^2;
 
% Initial Guess y = 1:
phi = sym(1);
 
% Loop Through Picard approximations
n = 5;
for i = 1:n 
    func = subs(f,y,phi);    
    func = subs(func,t,s);      
    phi = 1 + int(func, s, 0 ,t);   
end
 
% Plot the approximation
p = ezplot(phi, [-pi, pi]);
set(p, 'Color', 'green');
hold on
grid on;
 
% PLotting exact soln
ex = ezplot(tan(t+pi/4), [-pi, pi]);
set(ex,'Color','blue');

% Readability
title("Exact solution and fifth picard approximation for y'=1+y^2");
xlabel('t');
ylabel('y');
legend('Picard Fifth Approximation', 'Exact Solution','Location','NorthWest');